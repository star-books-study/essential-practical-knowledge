# 6장. 동시성, 데이터가 꼬이기 전에 잡아야 한다
## 서버와 동시 실행
- 서버가 동시에 여러 클라이언트 요청을 처리하는 방식
  - 클라이언트 요청마다 `스레드` 할당
  - `비동기 IO` (or 논블로킹 IO) 사용
    - 이 방식을 사용하더라도 단일 스레드만 사용하는 경우는 드물다

## 프로세스 수준에서의 동시 접근 제어
- 동시성 문제는 `프로세스` 수준, `DB` 수준 모두에서 검토해야 한다

### 잠금 (lock) 을 이용한 접근 제어
- 락은 **한번에 한 스레드만 획득할 수 있다**
  - ex. ReentrantLock (잠금 해제 코드 필요)
  - synchronized 키워드 사용 시 코드 블록이 끝나면 자동으로 잠금을 풀어주기에 unlock() 과 같은 메소드 호출이 불필요하다
  - ReentrantLock 은 synchronized 에 없는 잠금 획득 대기시간 지정 기능이 존재한다

### 동시 접근 제어를 위한 구성 요소
- ReentrantLock 은 한번에 1개 스레드만 잠금을 구할 수 있다. 즉, 한번에 한 스레드만 공유자원에 접근 가능

### 세마포어
- 세마포어는 **동시에 실행할 수 있는 스레드 수를 제한**한다
  - 자원에 대한 접근을 일정 수준으로 제한하고 싶을 때 사용!
- 자마 세마포어 구현체를 permit 이라 표현함
  - 이진 세마포어 : 동시 접근 가능한 스레드 1개
  - 계수 세마포어 : 지정한 수만큼 동시 접근 가능
- 세마포어 사용 순서
  - 퍼밋 획득 (P 연산) ~ 코드 실행 ~ 퍼밋 반환 (V 연산)

#### 읽기 쓰기 잠금
- 락 사용 시 데이터 변경하지 않더라도 동시 읽기가 안됨 -> 한번에 1개 스레드만 읽기 기능 실행가능하므로
- 따라서 쓰기 빈도 대비 읽기 빈도가 높을 경우, **읽기 성능이 떨어지는 문제 발생**
- 읽기 쓰기 잠금 특징
  - **쓰기 잠금은 한번에 한 스레드만**
  - **읽기 잠금은 한번에 여러 스레드 가능**
  - 한 스레드가 쓰는 동안 다른 스레드들은 읽기 잠금을 구할 수 없고, 읽기 잠금을 획득한 모든 스레드가 해제될 때까지 쓰기 잠금 구할 수 없다
  - ex. ReentrantReadWriteLock

### 원자적 타입 (Atomic Type)
- 락 사용 시 동시성 문제를 간단히 해결할 수 있으나 CPU 효율이 떨어지는 문제가 있다
  - 여러 스레드가 동시 실행될 때 락을 확보한 스레드를 제외한 나머지 스레드는 대기하기 때문
- **락을 사용하지 않으면서 동시성 문제 없이** 카운터를 구현하려면 `원자적 타입` 을 사용하면 된다
- AtomicInteger 는 내부적으로 CAS (Compare And Swap) 연산을 사용하며, 스레드를 멈추지 않고 다중 스레드 환경에서 안전하게 값을 변경할 수 있다

### 동시성 지원 컬렉션
- 동기화된 컬렉션을 사용하면, 데이터 변경하는 모든 연산에 락을 적용해서 한번에 한 스레드만 접근할 수 있도록 제한한다
  - **변경, 조회와 관련된 메소드가 모두 동기화된 블록에서 실행되어 동시성 문제를 해결**
```java
Map<String, String> map = new HashMap<>();
Map<String, String> syncMap = Collections.synchronizedMap(map);
syncMap.put("key", "value"); // put 메소드는 내부적으로 synchronized 로 처리됨
```
- 동시성 자체를 지원하는 컬렉션 타입을 사용하여 동시성 문제를 해결할 수도 있다 -> ConcurrentHashMap
  - 이 타입은 데이터를 변경할 때 잠금 범위를 최소화한다

## DB와 동시성
- **선점 잠금 (비관적 잠금)**
  - 동일한 레코드에 대해 **한번에 하나의 트랜잭션만 접근**할 수 있게 제어할 수 있다
  - 잠금을 먼저하는 방식
  - 다수가 데이터 변경 시도 시, 데이터를 정상적으로 변경할 가능성이 떨어지므로 "비관적"
- **비선점 잠금 (낙관적 잠금)**
  - **실제 잠금 없이 값을 비교해서 수정하는 방식**
  - 성공할 가능성이 높으므로 "낙관적" (성공할 가능성이 높다 == 다수의 데이터 변경이 아닌 경우)
> - 실패 가능성이 높은 비관적 상황 -> 동시성 문제를 해결하기 위해 한번에 1개 클라이언트만 접근 가능가능한 배타적 잠금 사용 (비관적 잠금)
> - 성공 가능성이 높은 낙관적 상황 -> 동시성 문제를 해결하기 위해 비관점 잠금까지는 사용 X. 값을 비교하는 방식으로 대응

### 선점(비관적) 잠금
- 선점 잠금 : 데이터에 먼저 접근한 트랜잭션이 잠금을 획득하는 방식
```sql
select * 
from 테이블
where 조건
for update
```
- 조건에 해당하는 레코드를 조회하면서 동시에 잠금 획득
<br><br>
- 분산 잠금 : **여러 프로세스**가 동시에 동일한 자원에 접근하지 못하도록 막는 방법
  - 간단한 분산락 필요 시, DB 에서 제공하는 선점 잠금을 사용할 수 있음
  - 트래픽이 많다면 레디스를 이용한 분산락 구현 고려 가능

### 비선점(낙관적) 잠금
- 명시적으로 잠금 사용하지 않고, **데이터를 조회한 시점의 값 <> 수정하려는 시점의 값이 같은지 비교하는 방식**
- 보통 정수 타입의 버전 컬럼 사용
```sql
--  1. select 쿼리 with version 컬럼
select ..., version
from 테이블
where id = 아이디

-- 2. 로직 수행

-- 3. update 쿼리 수행
update 테이블
set ..., version = version + 1
where id = 아이디
and version = [1에서 조회한 version 값]

-- 4. update 쿼리로 변경된 행 개수 0일 경우, 이미 다른 트랜잭션이 version 값 증가시킨 것 => 트랜잭션 롤백
-- 5. update 쿼리로 변경된 행 개수 1일 경우, 데이터 변경에 성공한 것 => 트랜잭션 커밋
```
- 비선점 잠금은 **잠금을 구하기 위한 대기 과정이 없으므로, 실패 시 사용자에게 더 빠르게 결과를 응답할 수 있다**

### 외부 연동과 잠금
- 트랜잭션 범위 내에서 외부 시스템과 연동해야 할 경우, 비선점 잠금보다 선점 잠금을 고려하는 게 좋다
  - 비선점 잠금을 사용하고 싶다면 트랜잭션 아웃박스 패턴을 적용해서 외부 연동을 처리할 수도 있다

### 증분 쿼리
- 선점 잠금 사용 시, 잠금 대기 시간만큼 **응답 시간이 길어진다**
- 비선점 잠금 사용 시, 대기 시간은 없지만 **변경 실패 에러가 자주 발생할 수 있다**
```sql
update table
set count = count + 1
where id = ?
```
- DB 는 count = count + 1 을 `원자적` 연산으로 처리한다
- **동일 데이터에 대한 원자적 연산이 동시 실행될 경우, 이를 순차적으로 실행하므로 데이터가 누락되는 문제는 발생하지 않는다**

## 잠금 사용 시 주의 사항
### 잠금 해제하기
- 잠금 사용 시 습관적으로 finally 블록에서 잠금 해제하는 코드를 작성하자

### 대기 시간 지정하기
```java
boolean acquired = lock.tryLock(5, TimeUnit.SECONDS);
if (!acquired) {
  throw ...
}

try {
  ...
} finally {
  lock.unlock();
}
```
- tryLock() 은 5초 간 잠금 획득을 시도하며, 5초 이내에 잠금 획득하면 true, 실패 시 false 반환

### 교착상태 (deadlock) 피하기
- 교착 상태를 해소하려면 **잠금 대기 시간을 제한하거나 지정한 순서대로 잠금을 획득하면 된다**
- 라이브락 : 활동을 하는 것 같지만 실제로 아무 것도 하지 않는 상태
  - 뭔가 동작을 하고 있다는 점에서 아무것도 하지 않고 대기하는 교착상태와는 다르다
  - 라이브락 해소 방식 : 우선순위 지정, 중재자, 임의 시간 대기
- 기아상태 : 프로세스나 스레드가 자원을 할당받지 못해 실행되지 못하는 상태
  - 기아상태 해소 방식 : 작업 우선순위 조정, 공유자원 독점 시간 제한

## 단일 스레드로 처리하기
- 동시성 문제를 피하기 위해 한 스레드만 자원에 접근하도록 하는 방법이 있다
- 데이터 변경이나 접근이 필요한 스레드는, **작업 큐에 필요한 작업을 추가하여 직접 상태에 접근하지 못하게 한다**
  > 작업 요청 스레드 1,2,3 ... > 작업 큐 > 상태 관리 스레드
- **두 스레드 간 데이터 공유 필요 시, 콜백이나 큐와 같은 수단으로 데이터 복제본 또는 불변 값 공유**
<br><br>
- 성능은 1/동시 실행할 작업 개수, 2/임계 영역의 실행 시간에 따라 달라진다
- 임계 영역의 실행 시간이 짧고, 동시 접근 스레드가 적을 경우 => 락 사용 (큐, 채널 처리하는 데 드는 시간보다 잠금 획득/해제 시간이 더 짧음)
- 임계 영역의 실행 시간이 길고, 동시 실행 작업이 많은 경우 => 큐, 채널 이용