# 6장. 동시성, 데이터가 꼬이기 전에 잡아야 한다
## 서버와 동시 실행
- 서버가 동시에 여러 클라이언트 요청을 처리하는 방식
  - 클라이언트 요청마다 `스레드` 할당
  - `비동기 IO` (or 논블로킹 IO) 사용
    - 이 방식을 사용하더라도 단일 스레드만 사용하는 경우는 드물다

## 프로세스 수준에서의 동시 접근 제어
- 동시성 문제는 `프로세스` 수준, `DB` 수준 모두에서 검토해야 한다

### 잠금 (lock) 을 이용한 접근 제어
- 락은 **한번에 한 스레드만 획득할 수 있다**
  - ex. ReentrantLock (잠금 해제 코드 필요)
  - synchronized 키워드 사용 시 코드 블록이 끝나면 자동으로 잠금을 풀어주기에 unlock() 과 같은 메소드 호출이 불필요하다
  - ReentrantLock 은 synchronized 에 없는 잠금 획득 대기시간 지정 기능이 존재한다

### 동시 접근 제어를 위한 구성 요소
- ReentrantLock 은 한번에 1개 스레드만 잠금을 구할 수 있다. 즉, 한번에 한 스레드만 공유자원에 접근 가능

### 세마포어
- 세마포어는 **동시에 실행할 수 있는 스레드 수를 제한**한다
  - 자원에 대한 접근을 일정 수준으로 제한하고 싶을 때 사용!
- 자마 세마포어 구현체를 permit 이라 표현함
  - 이진 세마포어 : 동시 접근 가능한 스레드 1개
  - 계수 세마포어 : 지정한 수만큼 동시 접근 가능
- 세마포어 사용 순서
  - 퍼밋 획득 (P 연산) ~ 코드 실행 ~ 퍼밋 반환 (V 연산)

#### 읽기 쓰기 잠금
- 락 사용 시 데이터 변경하지 않더라도 동시 읽기가 안됨 -> 한번에 1개 스레드만 읽기 기능 실행가능하므로
- 따라서 쓰기 빈도 대비 읽기 빈도가 높을 경우, **읽기 성능이 떨어지는 문제 발생**
- 읽기 쓰기 잠금 특징
  - **쓰기 잠금은 한번에 한 스레드만**
  - **읽기 잠금은 한번에 여러 스레드 가능**
  - 한 스레드가 쓰는 동안 다른 스레드들은 읽기 잠금을 구할 수 없고, 읽기 잠금을 획득한 모든 스레드가 해제될 때까지 쓰기 잠금 구할 수 없다
  - ex. ReentrantReadWriteLock