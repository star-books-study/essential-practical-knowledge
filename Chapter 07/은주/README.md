# 7장. IO 병목, 어떻게 해결하지
## 네트워크 IO 와 자원 효율
- DB는 TCP 기반 프로토콜을 사용하여 데이터를 주고 받는다
- 서버는 네트워크 통신을 기반으로 동작한다
```java
outputStream.write(...); // 출력스트림으로 데이터 송신
inputStream.read(...); // 입력스트림으로 데이터 수신
```
- 데이터 입출력이 완료될 때까지 스레드는 `블로킹` 되어 아무 작업도 하지 않고 입출력이 끝나기를 기다린다
  - 입출력 과정에서 블로킹이 발생하므로, 블로킹 IO 라고 하기도 한다
- 스레드가 대기하는데 시간을 소요한다 == **스레드를 실행하는 CPU 가 아무것도 하지 않는 시간이 생긴다**
  - 이 문제를 해결하기 위해 동시에 실행되는 스레드 개수를 늘려서, IO 대기에 따른 CPU 낭비를 줄일 수도 있다
  - 하지만 스레드는 수백 KB ~ 수 MB 메모리를 사용하므로 **사용자가 늘어나면 메모리가 병목이 될 수 있다**
  - 또한 동시 실행되는 스레드 증가 시, 컨텍스트 스위칭에 사용되는 시간도 증가한다
- 컨텍스트 스위칭
  - OS 는 여러 스레드를 번갈아가며 CPU 에 할당
  - 현재 실행 중인 스레드 상태를 기록하고, 다음에 실행할 스레드의 상태정보를 불러오는 과정을 컨텍스트 스위칭이라고 한다
  - 컨텍스트 스위칭을 하는 동안, CPU 는 실질적인 작업을 하지 않는다
- 서버 성능을 높이려면 `자원효율` 을 높이면 된다
  - IO 대기로 인한 **CPU 낭비를 줄이고,**
  - 요청을 처리하는 데 **필요한 메모리를 줄인다**
> ✅ **톰캣**
> - 기본적으로 멀티 스레드 모델로 구현됨
>   - 즉, **각 사용자 요청을 1개의 스레드가 처리**하는 thread-per-request 방식으로 동작
> - NIO 기반의 톰캣 동작 방식 -> 추가 필요
> - Thread 의 Idle 상태를 줄이기 위해 EventLoop 방식의 Reactive Programming이 개발됨
> 
> ✅ **thread-per-request vs. event loop**

## 가상 스레드로 자원 효율 높이기
- CPU 효율을 높이기 위한 방법 : 가상스레드 (자바), 고루틴 (Go) => `경량 스레드`
- 경량 스레드 : OS 가 관리하는 스레드가 아니라, JVM 과 같은 **언어의 런타임이 관리하는 스레드**