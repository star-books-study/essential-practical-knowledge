# 3장. 성능을 좌우하는 DB 설계와 쿼리
## 조회 트래픽을 고려한 인덱스 설계
- DB 테이블 설계 시, `조회 기능`과 `트래픽 규모` 고려 필요
- 풀스캔이 발생하지 않도록 하려면, 조회 패턴을 기준으로 인덱스 설계해야 한다
- 중간에 포함된 단어를 검색하기 위한 Like 조건 -> 풀스캔 유발
  - 엘라스틱서치 같은 검색 엔진 구성이 어렵다면, DB가 제공하는 `전문 검색 기능` 사용 고려
  - oracle Text 또는 MySQL 의 FULLTEXT 인덱스 사용하여 풀 스캔 없이 문자열 검색 쿼리 실행 가능

### 선택도를 고려한 인덱스 칼럼 선택
- 인덱스 생성시에는 선택도 (인덱스에서 특정 컬럼의 고유한 값 비율) 가 높은 컬럼을 골라야 한다
  - 카디널리티 == 해당 컬럼에 있는 고유한 값의 개수
  - 높은 카디널리티 == 대부분의 값이 고유하다

### 커버링 인덱스 활용하기
- `커버링 인덱스` : 특정 쿼리 실행하는 데 필요한 컬럼을 모두 포함하는 인덱스
  - 이 경우에는 **실제 데이터에 접근하지 않음 -> 쿼리 실행 시 필요한 컬럼이 모두 인덱스에 포함되어 있기 때문**
  - 실제 데이터 읽는 과정이 생략되므로 쿼리 실행 시간이 빠름
  > 쿼리에 필요한 모든 컬럼이 인덱스(leaf)에 이미 들어있으면, DB 엔진은 인덱스만 읽어서(=index-only / covering) 결과를 만들 수 있고, 따라서 테이블(힙/클러스터드 인덱스)의 행을 추가로 읽을 필요가 없다
- 인덱스는 조회 속도는 빠르게 해주지만, 데이터 추가/변경/삭제 시에는 인덱스 관리에 따른 비용(시간) 이 추가된다
  - 인덱스 자체도 데이터이므로, 인덱스가 많아질수록 메모리와 디스크 사용량도 함께 증가한다

## 몇 가지 조회 성능 개선 방법
### 미리 집계하기
- 집계 데이터를 미리 계산해서 별도 컬럼으로 저장
  - 하지만 이 집계 데이터를 계산하기 위한 증가/감소 쿼리 사용 시, DBMS 가 지정한 트랜잭션 격리 수준에서 `원자적` 처리가 이루어지는지 검증해야 한다

### 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기
- 지정한 오프셋으로 이동하기 위해 데이터를 세는 시간을 줄이려면, `특정 ID` 를 기준으로 조회해야 한다
  - 오프셋 사용시에는 지정한 오프셋만큼 데이터를 세는 시간이 필요한데 이 시간을 생략할 수 있어 실행시간이 빠르다

### 조회 범위를 시간 기준으로 제한하기
- 조회 범위를 `시간` 기준으로 제한 or 최신 데이터만 조회한다

### 전체 개수 세지 않기
- 데이터가 많아질수록 count 쿼리 실행시간도 증가한다
  - 조건에 해당하는 모든 데이터를 탐색해야 하기 때문!
  - **커버링 인덱스를 사용해도 전체 인덱스를 스캔해야 한다**

### 오래된 데이터 삭제 및 분리 보관하기
- 데이터 개수가 증가하지 않거나, 데이터 증가 속도를 낮추면 실행시간 증가 폭을 줄일 수 있다
- 데이터 증가 폭을 낮추려면 과거 데이터를 삭제하면 된다
  - **과거 데이터 삭제 시 데이터 개수를 일정하게 유지할 수 있어** 성능 또한 일정 수준으로 유지 가능
ex. 로그인 시도 내역은 이상 징후를 탐지하기 위한 목적이기에 장기간 보관할 필요가 없음

- 알아두기 : 단편화와 최적화
  - 일반 DB에서는 DELETE 쿼리를 실행해도, **DB가 사용하는 디스크 용량은 줄어들지 않는다**
  - DB는 해당 데이터가 삭제되었다는 표시만 남기고, **삭제된 공간은 향후 재사용한다**
  - 데이터가 반복적으로 추가, 변경, 삭제되는 과정에서 데이터가 흩어져 저장되고 빈공간이 생기는 `단편화` 현상이 발생할 수 있다
    - 단편화가 심해질 경우, 디스크 I/O 가 증가하면서 쿼리 성능이 저하될 수 있다
    - 또한 실제 보관 데이터크기보다 더 많은 디스크 공간을 사용하게 되어, 디스크 낭비도 발생한다
  - 단편화로 인한 성능 저하를 해결하려면, `최적화` 를 통해 **데이터를 재배치해 단편화를 줄이고, 물리적인 디스크 사용량까지 줄이면 된다**

### DB 장비 확장하기
- DB 장비를 수직으로 확장해 서비스를 가능한 상태로 유지하고, 개선할 시간을 번다

### 별도 캐시 서버 구성하기
- DB 를 확장하는 것보다 레디스와 같은 캐시서버 구성하는 것이 상대적으로 적은 부담이 된다

## 알아두면 좋을 몇 가지 주의사항
### 쿼리 타임아웃
- 앞선 요청을 아직 처리 중인 상황에서 새로운 요청이 유입되기 때문에, 응답 지연으로 인한 재시도는 서버 부하를 더욱 가중시킨다. 
- 쿼리 실행 시간을 제한 (`타임아웃 설정`) 하여 해당 요청을 정상적으로 종료 시킨다면, 사용자가 재시도를 하더라도 이전 요청이 처리중인 상태가 아니므로 동시 요청 수의 폭증을 막을 수 있다

### 상태 변경 기능은 복제 DB에서 조회하지 않기
- 주 DB의 트랜잭션 범위 내에서 데이터 변경, 복제 DB 에서 변경 대상이 될 수 있는 데이터 조회 시 데이터 불일치로 인해 문제가 생긴다
- 복제 DB 가 아닌 CUD 쿼리를 실행하는 주 DB 에서 SELECT 쿼리를 실행한다면 데이터 불일치로 인해 발생할 수 있는 오류를 방지할 수 있다

### 배치 쿼리 실행 시간 증가
- 집계 쿼리는 특성상 많은 데이터를 스캔하므로, **인덱스 설정을 통해 데이터를 직접 읽지 않고 인덱스만 스캔해 집계를 수행하도록 하자**
- 데이터를 일정 크기로 나눠 처리하는 것도 방법이다

### 타입이 다른 칼럼 조인 주의
```sql
select *
from user u, push p
where u.userId = p.receiverId 

-- u.userId : interger(10)
-- p.receiverId : varchar(200)
```
- 두 칼럼의 값을 비교할 때 **DB 는 타입 변환을 수행하는데, 이 변환은 각 행마다 발생**하며 결과적으로 receiverId 인덱스를 온전히 활용하지 못한다
- 비교하는 컬럼의 타입이 달라서 인덱스를 활용하지 못하는 문제를 해결하려면, **두 컬럼의 타입을 맞춰서 비교해야 한다**
```sql
select *
from user u, push p
where cast(u.userId as char character set utf8mb4) collate 'utf9mb4_unicode_ci' = p.receiverId
```

### 테이블 변경은 신중하게
- **MySQL 은 테이블을 변경할 때 새 테이블 생성 -> 원본 테이블 데이터 복사 -> 복사 완료 후 새 테이블로 대체 한다**
- 복사 과정에서 CUD 와 같은 DML 작업을 허용하지 않으므로 복사 시간만큼 서비스가 멈춘다

### DB 최대 연결 개수
- 새로 추가한 API 서버에서 DB 커넥션 생성에 실패한다면, DB에 설정된 `최대 연결 개수`를 확인해야 한다
- DB 서버 CPU 사용률 >= 70$ 일 경우 연결 개수를 늘리면 안된다
  - 연결 수가 많아지면 DB 부하는 더욱 증가하고 성능 저하가 발생한다
  - 캐시 서버 구성, 쿼리 튜닝 같은 조치를 통해 DB 부하를 낮추고 필요 시 연결 개수를 늘려야 한다

## 실패와 트랜잭션 고려하기
- DB 관련 코드를 작성할 때는 트랜잭션 시작, 종료 경계를 명확히 설정했는지 반드시 확인해야 한다