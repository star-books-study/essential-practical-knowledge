# 3장. 성능을 좌우하는 DB 설계와 쿼리
## 조회 트래픽을 고려한 인덱스 설계
- DB 테이블 설계 시, `조회 기능`과 `트래픽 규모` 고려 필요
- 풀스캔이 발생하지 않도록 하려면, 조회 패턴을 기준으로 인덱스 설계해야 한다
- 중간에 포함된 단어를 검색하기 위한 Like 조건 -> 풀스캔 유발
  - 엘라스틱서치 같은 검색 엔진 구성이 어렵다면, DB가 제공하는 `전문 검색 기능` 사용 고려
  - oracle Text 또는 MySQL 의 FULLTEXT 인덱스 사용하여 풀 스캔 없이 문자열 검색 쿼리 실행 가능

### 선택도를 고려한 인덱스 칼럼 선택
- 인덱스 생성시에는 선택도 (인덱스에서 특정 컬럼의 고유한 값 비율) 가 높은 컬럼을 골라야 한다
  - 카디널리티 == 해당 컬럼에 있는 고유한 값의 개수
  - 높은 카디널리티 == 대부분의 값이 고유하다

### 커버링 인덱스 활용하기
- `커버링 인덱스` : 특정 쿼리 실행하는 데 필요한 컬럼을 모두 포함하는 인덱스
  - 이 경우에는 **실제 데이터에 접근하지 않음 -> 쿼리 실행 시 필요한 컬럼이 모두 인덱스에 포함되어 있기 때문**
  - 실제 데이터 읽는 과정이 생략되므로 쿼리 실행 시간이 빠름
  > 쿼리에 필요한 모든 컬럼이 인덱스(leaf)에 이미 들어있으면, DB 엔진은 인덱스만 읽어서(=index-only / covering) 결과를 만들 수 있고, 따라서 테이블(힙/클러스터드 인덱스)의 행을 추가로 읽을 필요가 없다
- 인덱스는 조회 속도는 빠르게 해주지만, 데이터 추가/변경/삭제 시에는 인덱스 관리에 따른 비용(시간) 이 추가된다
  - 인덱스 자체도 데이터이므로, 인덱스가 많아질수록 메모리와 디스크 사용량도 함께 증가한다

### 몇 가지 조회 성능 개선 방법
#### 미리 집계하기
- 집계 데이터를 미리 계산해서 별도 컬럼으로 저장
  - 하지만 이 집계 데이터를 계산하기 위한 증가/감소 쿼리 사용 시, DBMS 가 지정한 트랜잭션 격리 수준에서 `원자적` 처리가 이루어지는지 검증해야 한다

#### 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기
- 지정한 오프셋으로 이동하기 위해 데이터를 세는 시간을 줄이려면, `특정 ID` 를 기준으로 조회해야 한다
  - 오프셋 사용시에는 지정한 오프셋만큼 데이터를 세는 시간이 필요한데 이 시간을 생략할 수 있어 실행시간이 빠르다

#### 조회 범위를 시간 기준으로 제한하기
- 조회 범위를 `시간` 기준으로 제한 or 최신 데이터만 조회한다

#### 전체 개수 세지 않기
- 데이터가 많아질수록 count 쿼리 실행시간도 증가한다
  - 조건에 해당하는 모든 데이터를 탐색해야 하기 때문!
  - **커버링 인덱스를 사용해도 전체 인덱스를 스캔해야 한다**

#### 오래된 데이터 삭제 및 분리 보관하기
- 데이터 개수가 증가하지 않거나, 데이터 증가 속도를 낮추면 실행시간 증가 폭을 줄일 수 있다
- 데이터 증가 폭을 낮추려면 과거 데이터를 삭제하면 된다
  - **과거 데이터 삭제 시 데이터 개수를 일정하게 유지할 수 있어** 성능 또한 일정 수준으로 유지 가능
ex. 로그인 시도 내역은 이상 징후를 탐지하기 위한 목적이기에 장기간 보관할 필요가 없음

- 알아두기 : 단편화와 최적화
  - 