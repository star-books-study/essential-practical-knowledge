# 3장. 성능을 좌우하는 DB 설계와 쿼리
## 성능에 핵심인 DB
- DB 성능은 연동하는 모든 서버 성능에 영향을 준다.
- `풀 스캔(full scan)` : 테이블의 모든 데이터를 순차적으로 읽는 것
  - where 절에 있는 조건에 대응하는 인덱스가 없을 때 발생
  - 인덱스를 사용하는 것보다 전체 데이터를 탐색하는 것이 더 빠를 때도 발생
## 조회 트래픽을 고려한 인덱스 설계
- DB 테이블을 설계할 때는 조회 기능과 트래픽 규모를 고려해야 한다.
- 풀 스캔이 발생하지 않도록 하려면 조회 패턴을 기준으로 인덱스를 설계해야 한다.
- 게시판의 경우, 카테고리별로 게시글 목록을 조회하는 패턴이 존재하므로 category 칼럼에 인덱스를 추가해서 조회 성능을 개선할 수 있다.
> 중간에 포함된 단어를 검색하기 위한 like 조건은 풀 스캔을 유발한다. -> 엘라스틱서치를 사용하거나 FULLTEXT 인덱스 사용

### 단일 인덱스와 복합 인덱스
> 데이터 총량보다 사용자 1명당 데이터량이 더 중요하다
- 많이들 하는 착각:
  - “하루 50만 건이면 복합 인덱스 무조건 필요하지 않나?” -> 아님
  - 조회 조건 단위가 ‘사용자’라면 → 사용자당 데이터 개수가 핵심
- 사용자당 수백 ~ 수천 건 -> userId 단일 인덱스도 충분
- 사용자당 수만 건 이상 -> `(userId, activityDate)` 복합 인덱스 필요

- “WHERE에 여러 컬럼이 있다고 무조건 복합 인덱스”는 오해
- 비교해야 할 row 수가 얼마나 줄어드느냐가 본질
- **“쿼리 실행 빈도 × 실행 시간”으로 판단하라**
  ```sql
  select activityDate, activityType, count(*)
  from activityLog
  where activityDate = '2024-07-28'
  group by activityType;
  ```
  - ❌ “느리니까 무조건 인덱스 추가”

  - ✅ “이 쿼리를 하루에 몇 번 실행하나?”
    - 하루 1번 (배치) -> 10~30초 걸려도 OK
    - 실시간 / 자주 호출	-> 복합 인덱스 + 커버링 고려
- 성능 최적화는 항상 ‘비즈니스 사용 패턴’과 같이 봐야 함

### 선택도를 고려한 인덱스 컬럼 선택
- 선택도 낮아도 인덱스가 필요한 경우가 있다
- 대표적인 반례: 작업 큐 (Job Queue)
  ```sql
  select *
  from jobqueue
  where status = 'W'
  order by jobid asc;
  ```
  - status 값: W / P / C → 선택도 매우 낮음
  - 하지만 W 상태만 계속 조회이 쿼리는 시스템 핵심 로직
- **자주 실행되고, 특정 소수 값만 조회** → 인덱스 필수

### 커버링 인덱스 활용하기
- **인덱스를 써도 느린 이유**를 설명해주는 개념
- 일반 인덱스

  1. 인덱스로 row 위치 찾음

  2. 실제 테이블(row)을 다시 읽음 ← 여기서 느려짐
- 커버링 인덱스
  1. SELECT + WHERE에 필요한 컬럼이 전부 인덱스에 있음
  2. 테이블 접근 자체가 없음
 
  ```sql
  -- 빠름 (커버링)
  select activityDate, activityType
  from activityLog
  where activityDate = '2024-07-31'
    and activityType = 'VISIT';
  ```
- 실무에서:

  - 통계
  
  - 목록 화면
  
  - 존재 여부 체크
### 인덱스는 필요한 만큼만 만들기
- 인덱스는 조회 성능 + 쓰기 성능 + 디스크를 동시에 잡아먹
- 문제 되는 상황
  ```
  (userId, activityDate)
  (userId, activityDate, activityType)
  ```
  - 두 번째 인덱스가 의미 있으려면? 사용자당 + 하루당 데이터가 많아야 함
  - 하루 수백 건이면 체감 효과 거의 없음
- 이 인덱스가 비교 row 수를 유의미하게 줄이는지 확인



## 몇 가지 조회 성능 개선 방법
### 미리 집계하기
- 좋아요 기능
  - 답변자 수와 '좋아요' 수를 보관할 칼럼을 추가한 뒤 '좋아요'를 누를 때마다 해당 칼럼의 값을 증가시키는 방법으로 미리 집계
### 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기
- 대규모 데이터에서 OFFSET은 사실상 금지
  ```
  limit 10 offset 99990
  ```
  - DB는 앞에서부터 99990개를 세야 함

  - 인덱스 있어도 소용 없음
- 실무 정답 : ID 기반 페이징
  ```sql
  where id < lastId
  order by id desc
  limit 10
  ```
  - 모바일 무한 스크롤에 특히 중요
  - 성능 + UX 둘 다 잡음
### 조회 범위를 시간 기준으로 제한하기
- 일자/월 단위로 범위를 제한하면 DB가 읽어야 하는 데이터가 확 줄어서 성능이 안정됨
  - 예: 뉴스 목록을 “전체”가 아니라 하루치로 조회
    ```
    regdt >= 'YYYY-MM-DD 00:00:00' AND regdt < '다음날 00:00:00'
    ```

    - 이때 필요한 인덱스는 보통 regdt 인덱스 하나로 충분.

- 하루 데이터가 많아도 카테고리까지 같이 조건을 넣으면 더 줄어들 수 있음

- 하지만 인덱스를 무조건 늘리는 게 답이 아니라, **하루 발행량(데이터 밀도)**에 따라 판단.

### 전체 개수 세지 않기

- COUNT(*)가 서비스 속도를 죽이는 진짜 원인
  - 전체 개수는 생각보다 비싸다
  - 데이터 많아질수록 인덱스 있어도 결국 전부 스캔
- 미리 집계하기
  ```
  survey(answerCnt, likedCnt)
  ```
  - 실무에서는 목록 조회 성능 수십 배 개선
  - 약간의 오차는 허용 가능
- 관리자용 통계는 원본 테이블로 다시 계산

### 별도 캐시 서버 구성하기
- 트래픽이 커지면 DB만으로 감당이 어려운 순간이 옴.

- 캐시를 도입하면 DB 부하를 크게 줄일 수 있고 상대적으로 도입 부담이 낮을 때가 많음
## 알아두면 좋을 몇 가지 주의 사항

### 쿼리 타임아웃
- 사용자가 재시도를 하더라도 이전 요청이 여전히 처리 중인 상태가 아니므로 동시 요청 수의 폭증을 막을 수 있다.
- 서비스의 기능과 특성에 따라 다르게 설정
