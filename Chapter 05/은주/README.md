# 5장. 비동기 연동, 언제 어떻게 써야 할까
- 동기 방식은 코드 순서 == 실행 순서이므로, 프로그램의 흐름을 직관적으로 이해할 수 있다
- 동기 방식이 외부 연동을 만났을 때, 외부 연동 실패가 전체 기능의 실패인지 확인해야 한다
- 다음 작업을 진행하기 위해 반드시 외부 연동 결과가 필요한 게 아니라면, 동기 대신 비동기 방식으로 연동하는 것을 고민해볼 필요가 있다
  - ex. 푸시 알림 / 포인트 지급 / 인증메시지 발송
- 비동기 방식으로 연동해도 되는 것의 특징
  - 연동에 **시차가 생겨도 문제가 되지 않음**
  - 실패 시 **재시도** 가능
  - 연동에 실패했을 때 **무시해도 되는 기능 존재**
  - 실패 시 **수동 처리** 기능 존재

## 별도 스레드로 실행하기
```java
// 1. 별도 스레드 활용
new Thread(...).start();

// 2. 스레드 풀 이용
ExecutorService executor = Executors.newFixedThreadPool(50);
executor.submit(() -> ...);
```
- 비동기로 실행하는 메소드는 익셉션이 전파되지 않으므로 트랜잭션 범위 내에서 비동기 코드 실행시에는 주의해야 한다
  - 별도 스레드로 실행되는 메소드를 **같은 스레드에서 실행되도록 수정 + 다시 비동기로 실행**할 수 있는 방안 적용 필요
- 스레드와 메모리
  - 스레드는 자체적으로 **일정 크기의 메모리 사용**
  - 스레드 풀 사용 시, **스레드를 일정 개수로 유지**할 수 있어 메모리 사용량도 일정하게 유지됨.
    - **미리 스레드를 생성하므로 스레드 생성 시간도 단축**됨
  - 비동기 실행 코드가 외부 API 호출 또는 DB 연동과 같은 네트워크 I/O 작업일 경우, 자바 언어의 `가상 스레드` 사용하는 것도 방법이다
    - 가상스레드는 실제 네이티브 스레드 (OS 스레드) 가 아닌 **런타임에서 관리하는 경량 스레드로 적은 메모리 사용**
    - 사용하는 메모리 적은 만큼 한번에 만들 수 있는 스레드 개수도 많음

## 메시징
- 메시징 시스템을 사용하였을 때의 이점
  - 두 시스템이 서로 영향을 주지 않는다
  - 확장에 용이하다
- **rabbitMQ** 특징
  - 클러스터를 통해 처리량 높일 수 있음
  - 메시지는 큐에 등록된 순서대로 소비자에게 전송됨
  - 푸시 모델 사용
    - 따라서 브로커가 소비자에 메시지를 전송하므로, 소비자 성능이 느려지면 큐에 과부하가 걸려 전반적인 성능 저하 가능성 있음
  - 여러 프로토콜 지원, 게시/구독 패턴 뿐만 아니라 요청/응답, 점대점 패턴 지원, 우선순위 지정하여 처리 순서 변경 가능
- **레디스 pub/sub**
  - rabbigMQ 대비 처리량이 높음
  - 구독자 없을 경우 메시지 유실
- 메시지 유실되어도 상관없다면 레디스 pub/sub 을 고려하자! 
- 트래픽 대량 발생시 카프카 고려하자!
- 트래픽 규모 크지 않고 메시지를 정확한 순서대로 소비자에게 전달 or 다양한 프로토콜 연동해야 한다면 rabbitMQ 고려하자!

### 메시지 생성 측 고려사항
- 메시지 유실 시 선택 가능한 방법
  - 무시
    - ex. 단순 로그 메시지 
  - 재시도
    - 중복된 메시지 전송 가능성 존재
  - 실패로그
    - 후처리에 필요한 데이터를 담고 있어야 함
- 잘못된 메시지가 전송되는 문제를 방지하려면, 트랜잭션 종료 후 메시지를 전송해야 한다 
- 글로벌 트랜잭션과 메시지 연동
  - 글로벌 트랜잭션 사용 시, **여러 자원 (여러 DB) 에 대한 변경을 한 트랜잭션으로 묶어 처리할 수 있다**
    - 이를 구현하는 알고리즘으로 `2단계 커밋` 을 사용하며 이를 2PC 라고 표현하기도 한다
  - 글로벌 트랜잭션 지원하는 메시징 시스템으로는 `activeMQ` 가 있고, **DB 수정과 메시지 전송/처리를 한 트랜잭션으로 묶을 수 있다**
  - 글로벌 트랜잭션 지원 메시지 시스템 사용하면 **실패에 대한 대응처리를 단순화할 수 있다**
  - 글로벌 트랜잭션 사용 시 2단계 커밋 처리 과정이 추가됨에 따라 성능에 영향을 주어 처리 속도가 느려진다

### 메시지 종류: 이벤트와 커맨드
- `이벤트` : 어떤 일이 발생했음을 알려주는 메시지
  - **상태 (데이터) 변경과 관련 있을 수도 있음**
    - ex. '주문함' 이벤트 , '배송을 완료함' 이벤트
  - **어떤 활동이 일어났다는 사실**을 나타내는 경우
    - ex. '로그인에 실패함' 이벤트 -> 사용자 상태는 유지
- `커맨드` : 무언가를 요청하는 메시지
  - 커맨드 메시지를 수신한 소비자는 **메시지로 요구받은 기능을 실행함** -> 메시지를 수신하는 측의 `기능 실행` 에 초점이 맞춰짐
  - ex. '포인트 지급하기' 메시지 -> 수신자는 포인트를 지급해야 함
- 커맨드 메시지는 원하는 수신자가 정해져있는 반면, 이벤트 메시지는 **발생한 사건에 관심이 있는 소비자가 메시지를 수신하는 방식**이다
  - 따라서 이벤트 메시지는 소비자 확장에 적합함

### 궁극적 일관성
- 주로 분산 시스템에서 데이터 복제 다룰 때 사용
- 두 데이터 저장소 간 일관성을 보장하나, 즉시가 아닌 일정 시간이 지난후에 일관성이 맞춰진다

## 트랜잭션 아웃박스 패턴
- 트랜잭션 아웃박스 패턴 : **메시지 데이터를 DB에 보관하는 방식**
  - 메시지 데이터 자체가 유실되지 않도록 해당 데이터를 DB 에 저장
  - 별도의 메시지 중계 프로세스가 주기적으로 저장된 메시지를 읽어서 메시징 시스템에 전송
- 발송 완료 표기방식 2가지
  - 아웃박스 테이블에 발송 상태 컬럼 관리 
  - 메시지 중계 서비스가 성공적으로 전송한 마지막 메시지 ID 별도 기록
    - 2개 이상의 메시지 중계 서비스가 하나의 아웃박스 테이블을 함께 사용한다면, 이 방식이 적합

## 배치 전송
- 배치 : 데이터를 비동기로 연동하는 가장 전통적인 방법
- 읽기 전용으로 DB 를 열어주는 것 (DB to DB)

## CDC (Change Data Capture)
- DB 는 커밋된 데이터만 변경 순서에 맞게 전달하며, CDC 처리기에는 롤백된 데이터가 전달되지 않는다
- CDC 처리기는 DB, 메시징 시스템, API 등 다양한 대상에 데이터를 전파할 수 있다
  - 두 시스템 간 데이터 동기화가 목적이라면, 단순히 DB - CDC - DB 로 데이터 복제 가능
<br>
- CDC 는 어떤 일이 발생했음을 알려주는 이벤트 메시지에 가깝다.<br> 하지만 '회원 테이블 데이터 변경 : 이전 암호, 이후 암호' 는 암호가 초기화되었다는 사실을 드러내지 않음 -> 단지 암호 컬럼 값이 변경된 사실만 알 수 있음

### CDC와 데이터 위치
- CDC 처리기는 변경 데이터를 **어디까지 처리했는지 기록해야 함**
- ex. MySQL 은 `바이너리 로그` 를 이용해서 CDC 구현 -> 각 로그 항목은 변경된 데이터, 로그파일에서의 포지션 (위치) 값을 가짐
- 이 위치를 기록해야만 CDC 처리기 재시작 시 마지막으로 조회한 로그부터 읽어올 수 있다

### CDC가 유용할 때
- 시스템이 복잡하여 연동 코드를 넣기 부담스러울 때 활용하면 좋음.
  - 연동 대상 시스템이 N개이고 서로 데이터를 처리하는 속도가 다를 경우, 중간에 메시징 시스템을 두면 유용
  - A 시스템 -> DB -> CDC 처리기 -> 카프카 -> 소비자 1,2,...